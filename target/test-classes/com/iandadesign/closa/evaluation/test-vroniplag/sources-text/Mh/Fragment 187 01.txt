A behaviour (c, a) will fire when the environment is in state $ s\in \mathcal{S} $ if and only if $ \mathcal{}see(s)\in c $. Let $ \mathcal{}Beh = \{(c, a) | c \subset P\ \hbox{and}\ a \in A\} $ be the set of all such rules. Associated with an agent's set of behaviour rules $ \mathcal{}R \subset Beh $ is a binary inhibition relation on the set of behaviours: $ \prec \subset R \times R. $ [...] We write $ \mathcal{}b_1 \prec b_2 $ if $ \mathcal{}(b_l, b_2) \in \prec $, and read this as '$ \mathcal{}b_l $ inhibits $ \mathcal{}b_2 $', that is, $ \mathcal{}b_l $ is lower in the hierarchy than $ \mathcal{}b_2, $ and will hence get priority over $ \mathcal{}b_2. $ The action function is then as shown in Figure 5.1. Thus action selection begins by first computing the set $ \mathcal{}fired $ of all behaviours that fire (5). Then, each behaviour (c,a) that fires is checked, to determine whether there is some other higher priority behaviour that fires. If not, then the action part of the behaviour, a, is returned as the selected action (8). If no behaviour fires, [Seite 92] then the distinguished action $ \mathcal{}null $ will be returned, indicating that no action has been chosen.