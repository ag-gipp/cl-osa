[p. 98] In order to ensure that horizontally architectures are consistent, they generally include a mediator function, which makes decisions about which layer has 'control' of the agent at any given time. The need for such central control is problematic; it means that the designer must potentially consider all possible interactions between layers. If there are n layers in the architecture, and each layer is capable of suggesting m possible actions, then this means there are $ m^n $ such interactions to be considered. [...] [p. 99] These problems are partly alleviated in a vertically layered architecture. We can subdivide vertically layered architectures into one-pass architectures (Figure 5.2(b)) and two-pass architectures (Figure 5.2(c)). In one-pass architectures, control flows sequentially through each layer, until the final layer generates action output. In two-pass architectures, information flows up the architecture (the first pass) and control then flows back down. [...] In both one-pass and two-pass vertically layered architectures, the complexity of interactions between layers is reduced: since there are n - 1 interfaces between n layers, then if each layer is capable of suggesting m actions, there are at most $ m^2 (n - 1) $ interactions to be considered between layers. This is clearly much simpler than the horizontally layered case. However, this simplicity comes at the cost of some flexibility: in order for a vertically layered architecture to make a decision, control must pass between each different layer. This is not fault tolerant: failures in any one layer are likely to have serious consequences for agent performance. In the remainder of this section, we will consider two examples of layered architectures: Innes Ferguson's TouringMachines, and Jörg Müller's InteRRaP. The former is an example of a horizontally layered architecture; the latter is a (two-pass) vertically layered architecture.